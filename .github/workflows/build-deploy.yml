name: Build and Deploy API

on:
  push:
    branches: [main]
    paths: 
      - 'app/**'
      - 'k8s/**'
      - '.github/workflows/build-deploy.yml'
  pull_request:
    branches: [main]
    paths:
      - 'app/**'
      - 'k8s/**'
      - '.github/workflows/build-deploy.yml'

# Required for OIDC authentication to AWS
permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: liatrio-demo-dev-api
  EKS_CLUSTER_NAME: liatrio-demo-dev-eks-xscgoqr8

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    environment: dev
    
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials using OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-BuildDeploy

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}
          tags: |
            type=raw,value=latest,enable={{is_default_branch}}
            type=sha,format=short

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: ./app
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    environment: dev
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials using OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-Deploy

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

      - name: Deploy to EKS
        run: |
          # Use the latest tag 
          IMAGE_URI="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:latest"
          
          echo "Using image: $IMAGE_URI"
          
          # Clean up any existing deployments first
          echo "=== Cleaning up existing deployments ==="
          kubectl delete deployment liatrio-demo-api --ignore-not-found=true
          kubectl delete deployment liatrio-demo-api-simple --ignore-not-found=true
          kubectl delete pod liatrio-demo-api-pod --ignore-not-found=true
          sleep 10
          
          # Update simple deployment manifest
          sed -i "s|IMAGE_URI_PLACEHOLDER|${IMAGE_URI}|g" k8s/simple-deployment.yaml
          
          # Show what we're deploying
          echo "=== Deployment manifest ==="
          cat k8s/simple-deployment.yaml
          echo ""
          
          # Apply simple deployment
          echo "=== Applying deployment ==="
          kubectl apply -f k8s/simple-deployment.yaml
          
          # Wait with shorter timeout and get status regardless
          echo "=== Waiting for deployment (60s timeout) ==="
          kubectl rollout status deployment/liatrio-demo-api-simple --timeout=60s || echo "Deployment timeout"
          
          # Get detailed status
          echo ""
          echo "=== Deployment Status ==="
          kubectl get deployment liatrio-demo-api-simple -o wide
          
          echo ""
          echo "=== Pod Status ==="
          kubectl get pods -l app=liatrio-demo-api-simple -o wide
          
          echo ""
          echo "=== Pod Details ==="
          kubectl describe pods -l app=liatrio-demo-api-simple
          
          echo ""
          echo "=== Recent Events ==="
          kubectl get events --sort-by='.lastTimestamp' | tail -10
          
          echo ""
          echo "=== Services ==="
          kubectl get services

      - name: Verify deployment
        if: always()  # Run this even if deploy step fails
        run: |
          echo "=== Final Status Check ==="
          
          # Check if pod is running
          POD_STATUS=$(kubectl get pods -l app=liatrio-demo-api-simple --no-headers 2>/dev/null | awk '{print $3}' | head -1 || echo "NotFound")
          echo "Pod Status: $POD_STATUS"
          
          if [ "$POD_STATUS" = "Running" ]; then
            echo "SUCCESS! Pod is running!"
            
            # Get load balancer URL
            LB_URL=$(kubectl get service liatrio-demo-api-simple-service -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
            if [ -n "$LB_URL" ]; then
              echo "Load Balancer URL: http://$LB_URL"
              echo "API Endpoint: http://$LB_URL/api"
              echo "Health Endpoint: http://$LB_URL/health"
            else
              echo "Load balancer still provisioning..."
            fi
            
            # Test pod logs
            echo ""
            echo "=== Application Logs ==="
            kubectl logs -l app=liatrio-demo-api-simple --tail=20 || echo "No logs yet"
            
          else
            echo "Pod not running. Status: $POD_STATUS"
            
            # Get logs anyway for debugging
            echo ""
            echo "=== Debug Logs ==="
            kubectl logs -l app=liatrio-demo-api-simple --tail=20 || echo "No logs available"
          fi
