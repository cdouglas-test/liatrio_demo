name: Build and Deploy API

on:
  push:
    branches: [main]
    paths: 
      - 'app/**'
      - 'k8s/**'
      - '.github/workflows/build-deploy.yml'
  pull_request:
    branches: [main]
    paths:
      - 'app/**'
      - 'k8s/**'
      - '.github/workflows/build-deploy.yml'

# Required for OIDC authentication to AWS
permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: liatrio-demo-dev-api
  EKS_CLUSTER_NAME: liatrio-demo-dev-eks-xscgoqr8

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        run: |
          cd app
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run unit tests
        run: |
          cd app
          python -m pytest test_app.py -v --tb=short --cov=app --cov-report=xml --cov-report=term-missing

      - name: Upload coverage reports to Codecov
        if: always()
        uses: codecov/codecov-action@v3
        with:
          file: ./app/coverage.xml
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: false

      - name: Test Docker build
        run: |
          cd app
          docker build -t liatrio-demo-api:test .

      - name: Integration test with Docker
        run: |
          cd app
          # Start container in background
          docker run -d --name test-container -p 8080:8080 liatrio-demo-api:test
          
          # Wait for container to start
          sleep 10
          
          # Test API endpoints
          echo "Testing /api endpoint..."
          curl -f http://localhost:8080/api | jq .
          
          echo "Testing /health endpoint..."
          curl -f http://localhost:8080/health | jq .
          
          echo "Testing /metrics endpoint..."
          curl -f http://localhost:8080/metrics | jq .
          
          # Cleanup
          docker stop test-container
          docker rm test-container

  security-scan:
    runs-on: ubuntu-latest
    needs: test
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run security scan on dependencies
        uses: pypa/gh-action-pip-audit@v1.0.8
        with:
          inputs: app/requirements.txt

      - name: Build Docker image for scanning
        run: |
          cd app
          docker build -t liatrio-demo-api:scan .

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'liatrio-demo-api:scan'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results.sarif'

  build-and-push:
    needs: [test, security-scan]
    runs-on: ubuntu-latest
    environment: dev
    
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials using OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-BuildDeploy

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}
          tags: |
            type=raw,value=latest,enable={{is_default_branch}}
            type=sha,format=short

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: ./app
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    environment: dev
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials using OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-Deploy

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

      - name: Deploy to EKS
        run: |
          # Use the latest tag 
          IMAGE_URI="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:latest"
          
          echo "Using image: $IMAGE_URI"
          
          # Clean up any existing deployments first
          echo "=== Cleaning up existing deployments ==="
          kubectl delete deployment liatrio-demo-api --ignore-not-found=true
          kubectl delete deployment liatrio-demo-api-simple --ignore-not-found=true
          kubectl delete pod liatrio-demo-api-pod --ignore-not-found=true
          sleep 10
          
          # Update simple deployment manifest
          sed -i "s|IMAGE_URI_PLACEHOLDER|${IMAGE_URI}|g" k8s/simple-deployment.yaml
          
          # Show what we're deploying
          echo "=== Deployment manifest ==="
          cat k8s/simple-deployment.yaml
          echo ""
          
          # Apply simple deployment
          echo "=== Applying deployment ==="
          kubectl apply -f k8s/simple-deployment.yaml
          
          # Wait with shorter timeout and get status regardless
          echo "=== Waiting for deployment (60s timeout) ==="
          kubectl rollout status deployment/liatrio-demo-api-simple --timeout=60s || echo "Deployment timeout"
          
          # Get detailed status
          echo ""
          echo "=== Deployment Status ==="
          kubectl get deployment liatrio-demo-api-simple -o wide
          
          echo ""
          echo "=== Pod Status ==="
          kubectl get pods -l app=liatrio-demo-api-simple -o wide
          
          echo ""
          echo "=== Pod Details ==="
          kubectl describe pods -l app=liatrio-demo-api-simple
          
          echo ""
          echo "=== Recent Events ==="
          kubectl get events --sort-by='.lastTimestamp' | tail -10
          
          echo ""
          echo "=== Services ==="
          kubectl get services

      - name: Verify deployment
        if: always()  # Run this even if deploy step fails
        run: |
          echo "=== Final Status Check ==="
          
          # Check if pod is running
          POD_STATUS=$(kubectl get pods -l app=liatrio-demo-api-simple --no-headers 2>/dev/null | awk '{print $3}' | head -1 || echo "NotFound")
          echo "Pod Status: $POD_STATUS"
          
          if [ "$POD_STATUS" = "Running" ]; then
            echo "SUCCESS! Pod is running!"
            
            # Get load balancer URL
            LB_URL=$(kubectl get service liatrio-demo-api-simple-service -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
            if [ -n "$LB_URL" ]; then
              echo "Load Balancer URL: http://$LB_URL"
              echo "API Endpoint: http://$LB_URL/api"
              echo "Health Endpoint: http://$LB_URL/health"
            else
              echo "Load balancer still provisioning..."
            fi
            
            # Test pod logs
            echo ""
            echo "=== Application Logs ==="
            kubectl logs -l app=liatrio-demo-api-simple --tail=20 || echo "No logs yet"
            
          else
            echo "Pod not running. Status: $POD_STATUS"
            
            # Get logs anyway for debugging
            echo ""
            echo "=== Debug Logs ==="
            kubectl logs -l app=liatrio-demo-api-simple --tail=20 || echo "No logs available"
          fi

  post-deploy-tests:
    needs: deploy
    runs-on: ubuntu-latest
    environment: dev
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials using OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-PostDeployTest

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

      - name: Wait for load balancer
        timeout-minutes: 10
        run: |
          echo "Waiting for load balancer to be ready..."
          for i in {1..60}; do
            LB_URL=$(kubectl get service liatrio-demo-api-simple-service -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
            if [ -n "$LB_URL" ]; then
              echo "Load balancer ready: $LB_URL"
              echo "LB_URL=$LB_URL" >> $GITHUB_ENV
              break
            fi
            echo "Attempt $i: Load balancer not ready yet..."
            sleep 10
          done

      - name: Test deployed API endpoints
        run: |
          if [ -n "$LB_URL" ]; then
            echo "Testing deployed API at: http://$LB_URL"
            
            # Test API endpoint
            echo "=== Testing /api endpoint ==="
            API_RESPONSE=$(curl -s -f "http://$LB_URL/api" || echo "FAILED")
            echo $API_RESPONSE | jq .
            
            # Verify required response format
            MESSAGE=$(echo $API_RESPONSE | jq -r '.message' 2>/dev/null || echo "")
            if [ "$MESSAGE" != "Automate all the things!" ]; then
              echo "❌ API endpoint test FAILED: Wrong message"
              exit 1
            fi
            
            # Test health endpoint
            echo "=== Testing /health endpoint ==="
            HEALTH_RESPONSE=$(curl -s -f "http://$LB_URL/health" || echo "FAILED")
            echo $HEALTH_RESPONSE | jq .
            
            # Verify health status
            STATUS=$(echo $HEALTH_RESPONSE | jq -r '.status' 2>/dev/null || echo "")
            if [ "$STATUS" != "healthy" ]; then
              echo "❌ Health endpoint test FAILED: Not healthy"
              exit 1
            fi
            
            # Test metrics endpoint
            echo "=== Testing /metrics endpoint ==="
            curl -s -f "http://$LB_URL/metrics" | jq .
            
            echo "✅ All API endpoint tests passed!"
            
          else
            echo "⚠️ Load balancer URL not available, using port-forward for testing"
            
            # Port-forward test as fallback
            kubectl port-forward service/liatrio-demo-api-simple-service 8080:80 &
            PF_PID=$!
            sleep 5
            
            # Test via port-forward
            curl -s -f "http://localhost:8080/api" | jq .
            curl -s -f "http://localhost:8080/health" | jq .
            
            # Cleanup
            kill $PF_PID
            
            echo "✅ Port-forward tests passed!"
          fi

      - name: Performance test
        run: |
          if [ -n "$LB_URL" ]; then
            echo "=== Running basic performance test ==="
            
            # Simple load test with curl
            for i in {1..10}; do
              START_TIME=$(date +%s%N)
              curl -s -f "http://$LB_URL/api" > /dev/null
              END_TIME=$(date +%s%N)
              DURATION=$(( (END_TIME - START_TIME) / 1000000 ))
              echo "Request $i: ${DURATION}ms"
            done
            
            echo "✅ Performance test completed!"
          else
            echo "⚠️ Skipping performance test - Load balancer URL not available"
          fi
